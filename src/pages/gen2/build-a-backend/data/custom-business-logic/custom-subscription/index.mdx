export const meta = {
  title: 'Add custom real-time subscription',
  description:
    'Customize your business logic to create custom real-time subscriptions.'
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can create a custom real-time subscription, when you need to accomplish generic PubSub use cases or want to add real-time notifications for your custom mutation. 

The process breaks down into these steps:
1. Define a custom subscription for designated mutations
3. (Optionally) Configure enhanced subscription filters

## Define a custom subscription

For every custom subscription, you need to set a return type, authorization rules, and, optionally, filter arguments. Use `a.subscription()` to define your custom subscription in your **amplify/data/resource.ts** file:

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Channel: a.customType({
    name: a.string(),
    data: a.json()
  }),

  // Define a mutation to publish events to
  publish: a.mutation()
    .arguments({
      name: a.string(),
      data: a.json()
    })
    .returns(a.ref('Channel'))
    .handler(a.handler.custom({
      entry: "./publish.js"
    }))
    .authorization([a.allow.private()]),
  
  // Subscribe to all events from the "publish" mutation
  receive: a.subscription(['publish'])
    .returns(a.ref('Channel'))
    .authorization([a.allow.public()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

For this example, we're building a generic PubSub capability. This requires us to convert the arguments for `publish` into the `Channel`'s format. Create a new `publish.js` file alongside your **amplify/data/resource.ts** file with the following contents:

```js
/**
 * @param {import('@aws-appsync/utils').Context} ctx
 */
export function request(ctx) {
  return {
    payload: ctx.args
  }
}

/**
 * @param {import('@aws-appsync/utils').Context} ctx
 */
export function response(ctx) {
  return ctx.result
}
```

## (Optionally) Configure subscription filters

You can configure subscription filters by adding arguments to the custom subscriptions. 

### Basic subscription filters based on exact match

By default, every argument specified will be exact-matched to the subscription event's output. In the following example, we can introduce a required `name` argument, which allows your users to filter events based on a specific channel name:

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Channel: a.customType({
    name: a.string(),
    data: a.json()
  }),

  // Define a mutation to publish events to
  publish: a.mutation()
    .arguments({
      name: a.string(),
      data: a.json()
    })
    .returns(a.ref('Channel'))
    .handler(a.handler.custom({
      entry: "./publish.js"
    }))
    .authorization([a.allow.private()]),
  
  // Subscribe to all events from the "publish" mutation
  receive: a.subscription(['publish'])
    // highlight-next-line
    .arguments({ name: a.string() })
    .returns(a.ref('Channel'))
    .authorization([a.allow.public()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

### Enhanced subscription filters for custom filtering logic

If you want to customize the filters beyond an argument exact match, you can attach a custom subscription handler. For this example, we'll allow a customer to pass in a `namePrefix` parameter that'll allow the end users to only receive channel events in channels that start with the `namePrefix`.

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Channel: a.customType({
    name: a.string(),
    data: a.json()
  }),

  // Define a mutation to publish events to
  publish: a.mutation()
    .arguments({
      name: a.string(),
      data: a.json()
    })
    .returns(a.ref('Channel'))
    .handler(a.handler.custom({
      entry: "./publish.js"
    }))
    .authorization([a.allow.private()]),
  
  // Subscribe to all events from the "publish" mutation
  receive: a.subscription(['publish'])
    // highlight-next-line
    .arguments({ namePrefix: a.string() })
    .returns(a.ref('Channel'))
    // highlight-start
    .handler(a.handler.custom({
      entry: "./receive.js"
    }))
    // highlight-end
    .authorization([a.allow.public()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

In your handler, you can set custom subscription filters based on arguments passed into the custom subscription. For this example, create a new **receive.js** file alongside the **amplify/data/resource.ts** file:

```js
import { util, extensions } from "@aws-appsync/utils"

// Subscription handlers must return a `null` payload on the request
export function request(ctx) { return { payload: null } }

/**
 * @param {import('@aws-appsync/utils').Context} ctx
 */
export function response(ctx) {
  const filter = {
    name: {
      beginsWith: ctx.args.namePrefix
    }
  }

  extensions.setSubscriptionFilter(util.transform.toSubscriptionFilter(filter))
  
  return null
}
```

## Connect to custom subscriptions client-side

From your generated Data client, you can find all your custom subscriptions under `client.subscriptions`.

```ts
const sub = client.subscriptions.receive({
  namePrefix: "messages"
}).subscribe({
  next: payload => {
    // handle incoming payload
  }
})

// To unsubscribe the subscription when needed
sub.unsubscribe()
```
