export const meta = {
  title: 'Modeling relationships',
  description:
    'Learn about the types of model relationships and modeling relationships.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };
}

Applications that work with data need well-defined entities to represent that data. Typically, entities are stored across different tables in a database, and items in a given table need to be **uniquely identified**. This is achieved by defining a field (or a combination of fields) that will hold a value (or values) to unambiguously refer to the item. When modeling applications, you often need to **establish relationships** between entities. This is done by adding a field that holds the value of the unique identifier of the related entity.

Retrieving an entity's related data can be expensive, so Amplify Data offers a way to specify lazy or eager loading of relationships. This is done through "custom selection sets." With eager loading, related data is retrieved immediately when the entity is loaded. With lazy loading, related data is only retrieved when explicitly requested. Custom selection sets give you control over when and how an entity's relationships are populated.

 ## Types of relationships

|Relationship|Description|Example|
|------------|--------|--|
|`a.hasMany()`|Creates a one-directional, one-to-many relationship between two models. | A **Post** has many **Comments**. This allows you to query all the comments from the post record.|
|`a.manyToMany()`| Creates a bidirectional relationship. Must be defined on both related models. | A **Blog** has many **Tags** and a **Tag** has many **Blogs**.|
|`a.hasOne()`|Creates a one-directional, one-to-one relationship between two models. | A **Project** has one **Team**. This allows you to query the team from the project record.|
|`a.belongsTo()`|Makes a "has one" or "has many" relationship bidirectional so you can read from both sides of the relationship. | A **Project** has one **Team** and a **Team** belongs to a **Project**. This allows you to reference the team from the project record and the other way around.|

## Model a "Has Many" relationship

Create a uni-directional, one-to-many relationship between two models using the `hasMany()` method. In the example below, a Team has many Members.

```typescript
const schema = a.schema({
  Team: a.model({
    mantra: a.string().required(),
    members: a.hasMany('Member'),
  }),
  Member: a.model({
    name: a.string(),
  }),
}).authorization([a.allow.public()]);
```

{/* Close on this conversation with Ian/Tim if we still wanna do this in the future. We can probably avoid some complexity due to the inferences. */}
Under the hood, Amplify creates a field on the target model from the "has many" relationship. This field stores the references back to the origin model. 

![Unidirectional @hasMany: Team -> Member request](/images/gen2/data-modeling/uni-has-many.png)

For example, let's walkthrough what happens when you query for the members of a team. Amplify will use the given team's primary key (`id`) to lookup all **Member**'s with a matching value in the `teamId` field.


<Callout info>If you want to query the relationship on both ends. For example, allowing users to query the members from the team and vice versa, review [Bi-Directional Relationship TK]</Callout>

### Create a "Has Many" relationship between records

```ts
const { data: team } = await client.models.Team.create({
  mantra: "Hello"
})

await client.models.Member.update({
  id: "SOME_MEMBER_ID",
  team
})
```

### Update a "Has Many" relationship between records

```ts
await client.models.Member.update({
  id: "SOME_MEMBER_ID",
  team
})
```

### Delete a "Has Many" relationship between records

```ts
await client.models.Member.update({
  id: "SOME_MEMBER_ID",
  team: undefined
})
```

### Lazy load a "Has Many" relationship

```ts
const { data: team } = await client.models.Team.get({ id: "MY_TEAM_ID"})

const { data: members } = await team.members()

members.forEach(member => console.log(member.id))
```

### Eagerly load a "Has Many" relationship

```ts
const { data: teamWithMembers } = await client.models.Team.get(
  { id: "MY_TEAM_ID" },
  { selectionSet: ["id", "members.*"] },
)

teamWithMembers.members.forEach(member => console.log(member.id))
```

## Model a "many-to-many" relationship
Create a many-to-many relationship between two models with the `manyToMany()` method. Provide a common `relationName` on both models to join them in a many-to-many relationship. 

```typescript
const schema = a.schema({
  Post: a.model({
    title: a.string(),
    content: a.string(),
    tags: a.manyToMany('Tag', { relationName: 'PostTags'})
  }),
  Tag: a.model({
    label: a.string(),
    posts: a.manyToMany('Post', { relationName: 'PostTags'})
  }),
}).authorization([a.allow.public()]);
```

Under the hood, Amplify creates a join table based on the `relationName` parameter. This join table has a `hasMany` and `belongsTo` relationship to both models.

![@manyToMany: Post -> Tags request](/images/gen2/data-modeling/many-to-many.png)

For example, to query the tags for a post, you need to first query all the related `PostTags` and then retrieve the related `Tag`s.

### Create a "many-to-many" relationship

To create a "many-to-many" relationship, you need to first create the records on either on the relationship and then create a new record in the join model with the relationship. 

In the following example, we create a **Post** and associate two new **Tag**s with it.

```ts
const { data: post } = await client.models.Post.create({
  title: "AWS Amplify now supports server-side rendered applications"
})

const { data: tag1 } = await client.models.Tag.create({
  label: "Frontend"
})

const { data: tag2 } = await client.models.Tag.create({
  label: "SSR"
})

await client.models.PostTags.create({
  post,
  tag: tag1
})

await client.models.PostTags.create({
  post,
  tag: tag2
})
```

### Delete a "many-to-many" relationship

When you delete a join table's record, you "unlink" the relationship between the two models. Deleting a record in the join table **does not** have a cascading delete effect on the connected models though.

```ts
await client.models.PostTags.delete({
  id: postTag.id
})
```

### Lazy load a "many-to-many" relationship

```ts
const { data: post } = await client.models.Post.get({
  id: "YOUR_POST_ID"
})

const { data: postTags } = await post.tags()

const tags = await Promise.all(postTags.map(postTag => postTag.tag()))
```

### Eager load a "many-to-many" relationship

```ts
const { data: post } = await client.models.Post.get({
  id: window.prompt("ID") ?? ""
}, {
  selectionSet: ["tags.*", "tags.tag.*"]
})

const tags = post.tags.map(postTag => postTag.tag)
```

## Model a "Has One" relationship

Create a one-directional, one-to-one relationship between two models using the `hasOne()` method. In the example below, a Customer has one Cart. By using `hasOne` this way, it will automatically generate a field to hold the identifier of the related model.

```typescript
const schema = a.schema({
  Customer: a.model({
    name: a.string(),
    activeCart: a.hasOne('Cart'),
  }),
  Cart: a.model({
    items: a.string().array(),
  }),
}).authorization([a.allow.public()]);
```

Under the hood, Amplify creates a field on the target model from the "has one" relationship. This field stores the references back to the origin model. 

![Unidirectional @hasOne: Customer -> Cart request](/images/gen2/data-modeling/uni-has-one.png)

For example, let's walkthrough what happens when you query for the cart of a customer. Amplify will use the given customer's primary key (`id`) to lookup a matching value in the **Cart** table in the `customerId` field.


### Create a "Has One" relationship between records

To create a "has one" relationship between records, first create record on the target model and then create a record on the origin model and assign the target model's record. 

```ts
const { data: cart } = await client.models.Cart.create({
  items: ["Eggs", "Cilantro"]
});

const { data: customer } = await client.models.Customer.create({
  name: 'Rene',
  activeCart: cart,
});
```

### Update a "Has One" relationship between records

To update a "Has One" relationship between records, provide another record from the target model in the `.update()` request. Under the hood, this will set the reference field of the old record to `undefined` and set the reference field in the new record to the primary key of the origin model's record.

For example, to change a customer's cart:

```ts
const { data: newCart } = await client.models.Cart.create({
  items: ["Mint"],
});

await client.models.Customer.update({
  id: project.id,
  activeCart: newCart
});
```

### Delete a "Has One" relationship between records

You can update the relationship field to `undefined` to delete a "Has One" relationship between records. Under the hood, this will set the reference field of the target model's record to `undefined`.

```ts
await client.models.Customer.update({
  id: project.id,
  activeCart: undefined,
});
```

### Lazy load a "Has One" relationship

```ts
const { data: customer } = await client.models.Customer.get({ id: "MY_CUSTOMER_ID"})
const { data: cart } = await customer.activeCart();
```

### Eagerly load a "Has One" relationship

```ts
const { data: customer } = await client.models.Customer.get(
  { id: "MY_CUSTOMER_ID" },
  { selectionSet: ['id', 'activeCart.*'] },
);
```

## Model a bidirectional relationship

You can make a "has one" or "has many" relationship bidirectional with the `belongsTo()` method. Using the bidirectionality of `belongsTo()`, you can query the related item from both sides of the relationship. 

<Callout>
**Note:** The `belongsTo()` method requires that a `hasOne()` or `hasMany()` relationship already exists from parent to the related model.
</Callout>

### Create a bidirectional "Has One" relationship

```typescript
const schema = a.schema({
  Customer: a.model({
    name: a.string(),
    activeCart: a.hasOne('Cart')
  }),
  Cart: a.model({
    items: a.string().array(),
    customer: a.belongsTo('Customer'),
  }),
}).authorization([a.allow.public()]);
```

<BlockSwitcher>
<Block name="Customer -> Cart request">

![Bidirectional @hasOne: Customer -> Cart request](/images/gen2/data-modeling/has-one-customer-to-cart.png)

</Block>
<Block name="Cart -> Customer request">
![Bidirectional @hasOne: Cart -> Customer request](/images/gen2/data-modeling/has-one-cart-to-customer.png)
</Block>

</BlockSwitcher>

```ts
const client = generateClient<Schema>();

const { data: customer } = await client.models.Customer.get({
  id: 'FABF27EE-25D2-4851-AE1C-09BCA1604C77'
});

const { data: cart } = await customer.activeCart();

// references back to the same customer as above
const { data: belongsToCustomer } = await cart.customer();
```

### Create a bidirectional "Has Many" relationship

```typescript
const schema = a.schema({
  Team: a.model({
    mantra: a.string(),
    members: a.hasMany('Member'),
  }),
  Member: a.model({
    name: a.string(),
    team: a.belongsTo('Team'),
  }),
}).authorization([a.allow.public()]);
```

<BlockSwitcher>
<Block name="Team -> Member request">

![Bidirectional @hasMany: Team -> Member request](/images/gen2/data-modeling/has-many-team-to-member.png)

</Block>
<Block name="Member -> Team request">
![Bidirectional @hasMany: Member -> Team request](/images/gen2/data-modeling/has-many-member-to-team.png)
</Block>

</BlockSwitcher>

```ts
const client = generateClient<Schema>();

const { data: team } = await client.models.Team.get({
  id: 'FABF27EE-25D2-4851-AE1C-09BCA1604C77'
});

const { data: members } = await post.members();
const firstMember = members[0];

// references back to the original team above
const { data: firstMembersTeam } = await firstMember.team();
```

## Model multiple relationships between two models

To create multiple relationships between the same two models, you must supply a `references` modifier and explicitly define the field that should be used to reference the relationship. 

```typescript
const schema = a.schema({
  Team: a.model({
    id: a.id(),
    title: a.string(),
    content: a.string(),
    players: a.hasMany("Person").references('playerTeamId'),
    coaches: a.hasMany("Person").references('coachTeamId'),
  }),
  Person: a.model({
    name: a.string(),
    playerTeamId: a.id(),
    coachTeamId: a.id(),
  }),
}).authorization([a.allow.public()]);
```

```ts
const client = generateClient<Schema>();

const { data: team } = await client.models.Team.get({ id: 'AE6191BF-FEB4-4D8B-867D-898A7DA33101' });

const { data: players } = await team.players();
const { data: coaches } = await team.coaches();
```
