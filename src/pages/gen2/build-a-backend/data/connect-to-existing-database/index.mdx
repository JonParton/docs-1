export const meta = {
  title: 'Connect your app to existing MySQL and PostgreSQL database.',
  description:
    'Learn how to connect your app to existing MySQL and PostgreSQL database.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify's native integration supports any MySQL or Postgres database, no matter if they're hosted on AWS within a VPC or outside of AWS with a 3rd party hosted database provider.

You must have these information handy for your database:

- Database hostname
- Database port
- Database username
- Database user password
- Database name

## Step 1 - Set secrets for database connection

First, provide all the database connection information as secrets, you can use the Amplify sandbox's secret functionality to set them or go to the Amplify console to set secrets in a shared environment:

<BlockSwitcher>
<Block name="Sandbox">

```bash
npx amplify sandbox secret set MYSQL_CONNECTION_STRING
# mysql://rene:password123@super-awesome-db.rene.amazonaws.com/main
```

</Block>

<Block name="Amplify console"></Block>

</BlockSwitcher>

## Step 2 - Generate database schema

Run the following command to generate the Data schema with your database connection information.

```bash
npx amplify generate schema-from-database --connection-uri-secret MYSQL_CONNECTION_STRING --out amplify/data/schema.sql.ts
```

<Callout info title="VPC connection">

If your database is behind a VPC, we'll autodetect the VPC configuration based on your connection string. This happens via a hostname lookup within your account. The sandbox profile in your account needs to have XYZ permissions to do a VPC lookup and connect to the VPC. (If your database is in a private subnet, we'll provision a Lambda to retrieve the database schema in order for us to generate the TypeScript data model.) TODO: Chris / Ed to connect on how best to implement this.

</Callout>

TK add call outs that no "implicit fields" are created for the customer

This creates a new **schema.sql.ts** with a schema reflecting the types of your database. Import the schema to your **amplify/data/resource.ts** file and

```ts
import { a, defineData } from '@aws-amplify/backend';
// highlight-next-line
import { schema as auroraSchema } from './schema.sql.ts';

// Relational database sources can coexist with DynamoDB tables managed by Amplify.
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    isDone: a.boolean()
  })
});

// Use the .combine() operator to stitch together the models backed by DynamoDB
// and the models backed by Postgres or MySQL databases.
// highlight-next-line
const combinedSchema = a.schema.combine([schema, auroraSchema]);

export type Schema = typeof combinedSchema;
export const data = defineData({
  // highlight-next-line
  schema: combinedSchema
});
```

## Step 3 - Add authorization rules

```ts
import { a, defineData } from '@aws-amplify/backend';
import { schema as sqlSchema } from './schema.sql.ts';

// Add an authorization rule to the schema
// highlight-next-line
const modifiedSqlSchema = sqlSchema.setAuthorization((models) => [
  models.todo.authorization((allow) => [allow.publicApiKey()]),
  models.todo.fields.content.authorization((allow) => [allow.guest()])
]);

const schema = a.schema({
  Post: a
    .model({
      title: a.string()
    })
    .authorization((allow) => [allow.publicApiKey()])
});

const combinedSchema = a.schema.combine([schema, modifiedSqlSchema]);

export type Schema = typeof schema;
export const data = defineData({
  schema: combinedSchema
});
```

## Step 4 - Deploy your Data resources using the cloud sandbox

Finally, you can now validate your Data resources with your cloud sandbox:

```bash
npx amplify sandbox
```

## Rename generated models and fields

```ts
import { a, defineData } from '@aws-amplify/backend';
import { schema as sqlSchema } from './schema.sql.ts';

// Rename models or fields to be more idiomatic for frontend code
// highlight-start
const modifiedSqlSchema = sqlSchema
  .renameModels(() => [['todo', 'Todo']])
  .renameModelFields((models) => [
    models.Todo.renameFields(() => [['title', 'content']])
  ]);

const schema = a.schema({
  Post: a
    .model({
      title: a.string()
    })
    .authorization([a.allow.public()])
});

const combinedSchema = a.schema.combine([schema, modifiedSqlSchema]);

export type Schema = typeof schema;
export const data = defineData({
  schema: combinedSchema
});
```

Step 5 - Configure the `amplify.yml` TK

Customers need to update the `amplify.yml` to generate the DB schema if the DB is in a different VPC. Etc Etc. TK

TK: npx amplify generate config --connection-string $BRANCH_CONNECTION_STRING

## Add relationships between tables

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as sqlSchema } from './schema.sql.ts'

// highlight-start
const modifiedSqlSchema = sqlSchema.relationships((models) => [
  models.Todo.addRelationships({
    // will be: a.hasMany("Comment", "todo_id")
    comments: a.hasMany("Comment", 'todo_id'),
    // will be: a.hasMany("Note", "todoId")
    notes: a.hasMany("Note", 'todoId')
  })
]);
// highlight-end

const ddbSchema = a.schema({
   Note: a.model({
     content: a.string(),
     todoId: a.id()
     todo: a.belongsTo("Todo", 'todoId')
   })
})

const combinedSchema = a.schema.combine([modifiedSqlSchema, ddbSchema])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

## Invoke SQL statements with custom queries and mutations

You can either define inline SQL statements or reference a file path containing custom sql statements in designated files. If both inline and custom statements are set, the sandbox/build should error out.

```ts

import { a, defineData } from '@aws-amplify/backend'
import { schema as sqlSchema } from './schema.sql.ts'

// Add custom mutations or queries that execute SQL statements
// highlight-start
sqlSchema.addQueries({
  searchTodoBasedOnGeolocation: a.query()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float()
    })
    .returns(a.ref("Todo").array())
    .handler(a.handler.inlineSql(`
      SELECT *
      FROM todos
      WHERE ST_DistanceSphere(
        location,
        ST_MakePoint(:lat, :long)
      ) <= :radiusInMeters`
    ))
    .authorization([a.allow.public()])
})
// highlight-end

// highlight-start
// Create a "updateTodoBasedOnLocation.sql" file with the statement
const modifiedSqlSchema = sqlSchema.addMutation({
  updateTodoBasedOnLocation: a.mutation()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float(),
      todoChange: a.ref("Todo")
    })
    .returns(a.ref("Todo"))
    .handler(a.handler.sqlReference('./updateTodoBasedOnLocation.sql'))
    .authorization([a.allow.public()])
})
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  modifiedSqlSchema
])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

### Exclude or include only specific tables to introspect

### Generate Data schemas for multiple databases

TK add connection string in console

TK trouble shooting guide
